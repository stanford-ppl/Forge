
.. role:: black
.. role:: gray
.. role:: silver
.. role:: white
.. role:: maroon
.. role:: red
.. role:: fuchsia
.. role:: pink
.. role:: orange
.. role:: yellow
.. role:: lime
.. role:: green
.. role:: olive
.. role:: teal
.. role:: cyan
.. role:: aqua
.. role:: blue
.. role:: navy
.. role:: purple

.. _DecisionTree:

DecisionTree
============

<auto-generated stub>

Static methods
--------------

.. parsed-literal::

  :maroon:`def` deserialize(encodedTree: Rep[:doc:`string`]): Rep[:doc:`decisiontree`]




Infix methods
-------------

.. parsed-literal::

  :maroon:`def` addNode(parent: Rep[:doc:`int`], isLeft: Rep[:doc:`boolean`], isLeaf: Rep[:doc:`boolean`], feature: Rep[:doc:`int`], threshold: Rep[:doc:`double`], impurity: Rep[:doc:`double`], numNodeSamples: Rep[:doc:`int`]): Rep[:doc:`int`]




*********

.. parsed-literal::

  :maroon:`def` capacity(): Rep[:doc:`int`]




*********

.. parsed-literal::

  :maroon:`def` feature(): Rep[:doc:`forgearray`\[:doc:`int`\]]




*********

.. parsed-literal::

  :maroon:`def` impurity(): Rep[:doc:`forgearray`\[:doc:`double`\]]




*********

.. parsed-literal::

  :maroon:`def` isLeaf(): Rep[:doc:`forgearray`\[:doc:`boolean`\]]




*********

.. parsed-literal::

  :maroon:`def` leftChildren(): Rep[:doc:`forgearray`\[:doc:`int`\]]




*********

.. parsed-literal::

  :maroon:`def` numNodeSamples(): Rep[:doc:`forgearray`\[:doc:`int`\]]




*********

.. parsed-literal::

  :maroon:`def` numNodes(): Rep[:doc:`int`]




*********

.. parsed-literal::

  :maroon:`def` pprint(): Rep[Unit]




*********

.. parsed-literal::

  :maroon:`def` predict(testPt: Rep[:doc:`densevector`\[:doc:`double`\]]): Rep[:doc:`tup2`\[:doc:`double`,:doc:`double`\]]




*********

.. parsed-literal::

  :maroon:`def` prob(): Rep[:doc:`forgearray`\[:doc:`double`\]]




*********

.. parsed-literal::

  :maroon:`def` rightChildren(): Rep[:doc:`forgearray`\[:doc:`int`\]]




*********

.. parsed-literal::

  :maroon:`def` serialize(): Rep[:doc:`string`]

 For now we use a simple text-format to persist the tree. Eventually, we probably will want to switch to a binary format for efficiency in saving and loading large forests. 


*********

.. parsed-literal::

  :maroon:`def` threshold(): Rep[:doc:`forgearray`\[:doc:`double`\]]




*********

.. parsed-literal::

  :maroon:`def` value(): Rep[:doc:`forgearray`\[:doc:`double`\]]




Related methods
---------------

.. parsed-literal::

  :maroon:`def` dtree(trainingSet: Rep[:doc:`densetrainingset`\[:doc:`double`,:doc:`double`\]], maxDepth: Rep[:doc:`int`] = unit(-1), maxNumFeatures: Rep[:doc:`int`] = unit(-1), minSamplesSplit: Rep[:doc:`int`] = 2, minSamplesLeaf: Rep[:doc:`int`] = 1, useSamples: Rep[:doc:`indexvector`] = unit(null.asInstanceOf[IndexVector]), criterion: TCriterion = MSE): Rep[:doc:`decisiontree`]




