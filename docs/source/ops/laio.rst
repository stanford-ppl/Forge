
.. role:: black
.. role:: gray
.. role:: silver
.. role:: white
.. role:: maroon
.. role:: red
.. role:: fuchsia
.. role:: pink
.. role:: orange
.. role:: yellow
.. role:: lime
.. role:: green
.. role:: olive
.. role:: teal
.. role:: cyan
.. role:: aqua
.. role:: blue
.. role:: navy
.. role:: purple

.. _LAio:

LAio
====

<auto-generated stub>

Related methods
---------------

.. parsed-literal::

  :maroon:`def` deleteFile(x: Rep[:doc:`string`]): Rep[Unit]




*********

.. parsed-literal::

  :maroon:`def` fileExists(x: Rep[:doc:`string`]): Rep[:doc:`boolean`]




*********

.. parsed-literal::

  :maroon:`def` fileLength(x: Rep[:doc:`string`]): Rep[:doc:`long`]




*********

.. parsed-literal::

  :maroon:`def` readMatrix(path: Rep[:doc:`string`]): Rep[:doc:`densematrix`\[:doc:`double`\]]




*********

.. parsed-literal::

  :maroon:`def` readMatrix(path: Rep[:doc:`string`], delim: Rep[:doc:`string`]): Rep[:doc:`densematrix`\[:doc:`double`\]]




*********

.. parsed-literal::

  :maroon:`def` readMatrix(path: Rep[:doc:`string`], schemaBldr: (Rep[:doc:`string`]) => Rep[Elem], delim: Rep[:doc:`string`] = unit("\\s+"), trim: Rep[:doc:`boolean`] = true): Rep[:doc:`densematrix`\[Elem\]]




*********

.. parsed-literal::

  :maroon:`def` readMatrixAndParse(path: Rep[:doc:`string`], schemaBldr: (Rep[:doc:`densevector`\[:doc:`string`\]]) => Rep[:doc:`densevector`\[Elem\]], delim: Rep[:doc:`string`] = unit("\\s+"), trim: Rep[:doc:`boolean`] = true): Rep[:doc:`densematrix`\[Elem\]]




*********

.. parsed-literal::

  :maroon:`def` readVector(path: Rep[:doc:`string`]): Rep[:doc:`densevector`\[:doc:`double`\]]

 For fusion and cluster execution, reads should be pure. however, in that case we need a different way to order them with respect to writes / deletes. one solution would be to implicitly convert strings to mutable file objects, and (manually) CSE future conversions to return the original mutable object.  Currently, reading and writing the same file in the same program is not supported, unless there is an alternate dependency chain from the output being written to the input (e.g. the output vector or matrix explicitly depends on the one being read). 


*********

.. parsed-literal::

  :maroon:`def` readVector(path: Rep[:doc:`string`], schemaBldr: (Rep[:doc:`string`]) => Rep[Elem]): Rep[:doc:`densevector`\[Elem\]]




*********

.. parsed-literal::

  :maroon:`def` readVectorAndParse(path: Rep[:doc:`string`], schemaBldr: (Rep[:doc:`densevector`\[:doc:`string`\]]) => Rep[Elem], delim: Rep[:doc:`string`] = unit("\\s+"), trim: Rep[:doc:`boolean`] = true): Rep[:doc:`densevector`\[Elem\]]




*********

.. parsed-literal::

  :maroon:`def` writeMatrix(m: Rep[:doc:`densematrix`\[Elem\]], path: Rep[:doc:`string`], delim: Rep[:doc:`string`] = unit("    ")): Rep[Unit]




*********

.. parsed-literal::

  :maroon:`def` writeVector(v: Rep[:doc:`densevector`\[Elem\]], path: Rep[:doc:`string`]): Rep[Unit]




