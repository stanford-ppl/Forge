
.. role:: black
.. role:: gray
.. role:: silver
.. role:: white
.. role:: maroon
.. role:: red
.. role:: fuchsia
.. role:: pink
.. role:: orange
.. role:: yellow
.. role:: lime
.. role:: green
.. role:: olive
.. role:: teal
.. role:: cyan
.. role:: aqua
.. role:: blue
.. role:: navy
.. role:: purple

.. _T:

T
=

<auto-generated stub>

Infix methods
-------------

.. parsed-literal::

  :maroon:`def` +(y: String): Rep[:doc:`string`]




*********

.. parsed-literal::

  :maroon:`def` AsInstanceOf(): Rep[R]

Casts this to the given type


*********

.. parsed-literal::

  :maroon:`def` IsInstanceOf(): Rep[:doc:`boolean`]

Checks if this is the specified type


*********

.. parsed-literal::

  :maroon:`def` toDouble(): Rep[:doc:`double`]

Converts this numeric value to an Double


*********

.. parsed-literal::

  :maroon:`def` toFloat(): Rep[:doc:`float`]

Converts this numeric value to a Float


*********

.. parsed-literal::

  :maroon:`def` toInt(): Rep[:doc:`int`]

Converts this numeric value to an Int


*********

.. parsed-literal::

  :maroon:`def` toLong(): Rep[:doc:`long`]

Converts this numeric value to a Long


*********

.. parsed-literal::

  :maroon:`def` unsafeImmutable(): Rep[T]

Gives a hint to the compiler to consider this value as immutable for future operations Note that this operation is unsafe as it does not prevent mutations prior to this call. For example, in:


.. parsed-literal::
   :maroon:`val` x = Array[Int](32)
   :maroon:`for` (i <- 0 until N) {
     x(i) = i
     f(x.unsafeImmutable)
   }


This will tell the compiler that x is not mutable in the function x, but x can still be mutated after this call has been made (in the next iteration of the loop, for example). 


*********

.. parsed-literal::

  :maroon:`def` unsafeMutable(): Rep[T]

Enables unsafe mutation of this value.


