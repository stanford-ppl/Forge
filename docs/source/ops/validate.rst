
.. role:: black
.. role:: gray
.. role:: silver
.. role:: white
.. role:: maroon
.. role:: red
.. role:: fuchsia
.. role:: pink
.. role:: orange
.. role:: yellow
.. role:: lime
.. role:: green
.. role:: olive
.. role:: teal
.. role:: cyan
.. role:: aqua
.. role:: blue
.. role:: navy
.. role:: purple

.. _Validate:

Validate
========

<auto-generated stub>

Related methods
---------------

.. parsed-literal::

  :maroon:`def` AUC(unsortedROCs: Rep[:doc:`densevector`\[:doc:`tup2`\[:doc:`double`,:doc:`double`\]\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` ROC(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`tup2`\[:doc:`double`,:doc:`double`\]]




*********

.. parsed-literal::

  :maroon:`def` ROCCurve(testSet: Rep[TS\[T,:doc:`boolean`\]], classify: (Rep[:doc:`double`]) => (Rep[:doc:`int`]) => Rep[:doc:`boolean`], numThresholds: Rep[:doc:`int`] = 10)(:maroon:`implicit` ev0: TrainingSetLike[T,:doc:`boolean`,TS],ev1: Manifest[TS\[T,:doc:`boolean`\]]): Rep[:doc:`densevector`\[:doc:`tup2`\[:doc:`double`,:doc:`double`\]\]]




*********

.. parsed-literal::

  :maroon:`def` ROCCurveBatch(testSet: Rep[TS\[T,:doc:`boolean`\]], classify: (Rep[:doc:`double`]) => (Rep[:doc:`indexvector`]) => Rep[:doc:`densevector`\[:doc:`boolean`\]], numThresholds: Rep[:doc:`int`] = 10)(:maroon:`implicit` ev0: TrainingSetLike[T,:doc:`boolean`,TS],ev1: Manifest[TS\[T,:doc:`boolean`\]]): Rep[:doc:`densevector`\[:doc:`tup2`\[:doc:`double`,:doc:`double`\]\]]




*********

.. parsed-literal::

  :maroon:`def` accuracy(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` confusionMatrix(testSet: Rep[TS\[T,:doc:`boolean`\]], classify: (Rep[:doc:`int`]) => Rep[:doc:`boolean`], numSamples: Rep[:doc:`int`] = unit(-1))(:maroon:`implicit` ev0: TrainingSetLike[T,:doc:`boolean`,TS],ev1: Manifest[TS\[T,:doc:`boolean`\]]): Rep[:doc:`densematrix`\[:doc:`int`\]]

 Generate a confusion matrix for the given classifier and testSet. 


*********

.. parsed-literal::

  :maroon:`def` confusionMatrixBatch(testSet: Rep[TS\[T,:doc:`boolean`\]], classify: (Rep[:doc:`indexvector`]) => Rep[:doc:`densevector`\[:doc:`boolean`\]], numSamples: Rep[:doc:`int`] = unit(-1))(:maroon:`implicit` ev0: TrainingSetLike[T,:doc:`boolean`,TS],ev1: Manifest[TS\[T,:doc:`boolean`\]]): Rep[:doc:`densematrix`\[:doc:`int`\]]

 The same as confusionMatrix, except process testSamples as a batch. 


*********

.. parsed-literal::

  :maroon:`def` crossValidate(dataSet: Rep[TS\[T,:doc:`boolean`\]], train: (Rep[TS\[T,:doc:`boolean`\]]) => Rep[M], classify: (Rep[M],Rep[TS\[T,:doc:`boolean`\]],Rep[:doc:`int`]) => Rep[:doc:`boolean`], metric: (Rep[:doc:`densematrix`\[:doc:`int`\]]) => Rep[:doc:`double`], numFolds: Rep[:doc:`int`] = 10, verbose: Rep[:doc:`boolean`] = false)(:maroon:`implicit` ev0: TrainingSetLike[T,:doc:`boolean`,TS],ev1: Manifest[TS\[T,:doc:`boolean`\]]): Rep[:doc:`double`]

 Compute a cross-validated score for the classifier using a user-specified metric from a confusion matrix to a score (e.g. accuracy, precision). 


*********

.. parsed-literal::

  :maroon:`def` crossValidateAUC(dataSet: Rep[TS\[T,:doc:`boolean`\]], train: (Rep[TS\[T,:doc:`boolean`\]]) => Rep[M], classify: (Rep[M],Rep[TS\[T,:doc:`boolean`\]],Rep[:doc:`int`]) => Rep[:doc:`double`], numFolds: Rep[:doc:`int`] = 10, numThresholds: Rep[:doc:`int`] = 10)(:maroon:`implicit` ev0: TrainingSetLike[T,:doc:`boolean`,TS],ev1: Manifest[TS\[T,:doc:`boolean`\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` crossValidateAUCBatch(dataSet: Rep[TS\[T,:doc:`boolean`\]], train: (Rep[TS\[T,:doc:`boolean`\]]) => Rep[M], classify: (Rep[M],Rep[TS\[T,:doc:`boolean`\]],Rep[:doc:`indexvector`]) => Rep[:doc:`densevector`\[:doc:`double`\]], numFolds: Rep[:doc:`int`] = 10, numThresholds: Rep[:doc:`int`] = 10)(:maroon:`implicit` ev0: TrainingSetLike[T,:doc:`boolean`,TS],ev1: Manifest[TS\[T,:doc:`boolean`\]]): Rep[:doc:`double`]

 Same as crossValidateAUC, except with a batch of test samples at a time. 


*********

.. parsed-literal::

  :maroon:`def` crossValidateBatch(dataSet: Rep[TS\[T,:doc:`boolean`\]], train: (Rep[TS\[T,:doc:`boolean`\]]) => Rep[M], classify: (Rep[M],Rep[TS\[T,:doc:`boolean`\]],Rep[:doc:`indexvector`]) => Rep[:doc:`densevector`\[:doc:`boolean`\]], metric: (Rep[:doc:`densematrix`\[:doc:`int`\]]) => Rep[:doc:`double`], numFolds: Rep[:doc:`int`] = 10, verbose: Rep[:doc:`boolean`] = false)(:maroon:`implicit` ev0: TrainingSetLike[T,:doc:`boolean`,TS],ev1: Manifest[TS\[T,:doc:`boolean`\]]): Rep[:doc:`double`]

 The same as crossValidate, except with a batch of test samples at a time. 


*********

.. parsed-literal::

  :maroon:`def` crossValidateRaw(dataSet: Rep[TS\[T,:doc:`boolean`\]], train: (Rep[TS\[T,:doc:`boolean`\]]) => Rep[M], \_numFolds: Rep[:doc:`int`] = 10)(evalTestSet: (Rep[M],Rep[TS\[T,:doc:`boolean`\]]) => Rep[R])(:maroon:`implicit` ev0: TrainingSetLike[T,:doc:`boolean`,TS],ev1: Manifest[TS\[T,:doc:`boolean`\]]): Rep[:doc:`densevector`\[R\]]

 A generic cross validate routine that is shared by crossValidate and crossValidateBatch. 


*********

.. parsed-literal::

  :maroon:`def` fallout(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` fnr(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` fpr(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` fscore(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` holdOut(dataSet: Rep[TS\[T,L\]], pct: Rep[:doc:`double`])(:maroon:`implicit` ev0: TrainingSetLike[T,L,TS],ev1: Manifest[TS\[T,L\]]): Rep[:doc:`tup2`\[TS\[T,L\],TS\[T,L\]\]]




*********

.. parsed-literal::

  :maroon:`def` holdOut2(dataSet: Rep[TS\[T,L\]], pctValidationSamples: Rep[:doc:`double`], pctTestSamples: Rep[:doc:`double`])(:maroon:`implicit` ev0: TrainingSetLike[T,L,TS],ev1: Manifest[TS\[T,L\]]): Rep[:doc:`tup3`\[TS\[T,L\],TS\[T,L\],TS\[T,L\]\]]




*********

.. parsed-literal::

  :maroon:`def` precision(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` recall(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` sensitivity(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` specificity(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` tnr(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`double`]




*********

.. parsed-literal::

  :maroon:`def` tpr(x: Rep[:doc:`densematrix`\[:doc:`int`\]]): Rep[:doc:`double`]




